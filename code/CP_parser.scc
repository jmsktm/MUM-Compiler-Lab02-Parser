Helpers
    all = [0..0xffff];
    space  = ' ';          
    lf  = 0x000a; // line feed
    cr  = 0x000d; // carriage return
    ff  = 0x000c; // form feed
    ht  = 0x0009; // tab

    eol = cr | lf | cr lf;
    not_eol = [all - [cr + lf]];
    not_star = [all - '*'];
    not_star_slash = [not_star - '/'];

    valid_string_literal_chars = [not_eol - '"'];

    simple_char_seq = ' ' | '!' | '"' | '#' | '$' | '%' | '&' | '(' | ')' 
        | '*' | '+' | ',' | '-' | '.' | '/' | ':' | ';' | '<' | '=' | '>' 
        | '?' | '@' | '[' | ']' | '^' | '_' | '`' | '{' | '|' | '}' | '~'
        | ['a' .. 'z'] | ['A' .. 'Z'] | ['0' .. '9'];
    simple_escape_seq = '\\' | '\' ''' | '\n' | '\t' | '\r' | '\b' | '\f' | '\"' ;

    zero = '0';
    digit = ['0' .. '9'];
    non_zero_digit = [digit - zero];
    digit_sequence = digit+;

    decimal = '.';
    sign = '+' | '-';
    float_mandatory_prefix_num = digit+ decimal digit*;
    float_mandatory_suffix_num = digit* decimal digit+;
    exponent_part = ('e' | 'E') sign? digit_sequence;

    underscore = '_';
    lower_alpha = ['a' .. 'z'];
    upper_alpha = ['A' .. 'Z'];
    numeric = ['0' .. '9'];
    alpha = [lower_alpha + upper_alpha];
    alpha_numeric = [alpha + numeric];
    alpha_underscore = [alpha + underscore];
    alpha_numeric_underscore = [alpha_numeric + underscore];

States
    normal;

Tokens
    comment = 
        ('//' not_eol* eol) |
        ('/*' not_star* '*'+ (not_star_slash not_star* '*'+)* '/');

    string_literal = ('"' valid_string_literal_chars* '"');
    char_literal = (''' simple_char_seq ''');
    escape_string_literal = ('"' (simple_escape_seq | valid_string_literal_chars)* '"');

    escape = (''' simple_escape_seq ''');

    plus = '+';
    minus = '-';
    mult = '*';
    div = '/';
    less_than = '<';
    less_than_or_eq= '<=';
    greater_than = '>';
    greater_than_or_eq = '>=';
    equals = '==';
    and = '&&';
    or = '||';
    not = '!';
    colon = ':';
    semicolon = ';';
    comma = ',';
    l_par = '(';
    r_par= ')';
    l_brace = '{';
    r_brace = '}';
    l_bkt= '[';
    r_bkt= ']';
    not_equals = '!=';
    equal_to = '=';
    pointer = '->';
    dot = '.';
    modulo = '%';

    float_lit = ((float_mandatory_prefix_num  | float_mandatory_suffix_num) exponent_part?);

    white_space = (space | ht | ff | eol)*;

    bool = 'bool';
    break = 'break';
    char = 'char';
    const = 'const';
    continue = 'continue';
    kclass = 'class';
    do = 'do';
    else = 'else';
    false = 'false';
    float = 'float';
    if = 'if';
    int = 'int';
    new = 'new';
    null = 'null';
    private = 'private';
    protected = 'protected';
    public = 'public';
    return = 'return';
    static = 'static';
    string = 'string';
    struct = 'struct';
    this = 'this';
    true = 'true';
    while = 'while';
    void = 'void';

    integer_literal = (zero | non_zero_digit digit*);
    identifier = (alpha_underscore alpha_numeric_underscore*);

Ignored Tokens
    white_space,
    comment;

Productions
    program = 
        {class_decls} class_decls;
    
    class_decls =
        {mult_class_decl} class_decls class_decl
        | {single_class_decl} class_decl;
    
    class_decl =
        {empty_class_decl} class_hdr l_brace r_brace
        | {class_decl} class_hdr l_brace member_decls r_brace;
    
    class_hdr =
        {class_hdr} kclass identifier;
    
    member_decls =
        {mult_member_decl} member_decls member
        | {single_member_decl} member;
    
    member =
        {field} field
        | {method} method
        | {no_member} semicolon;
    
    field =
        {field_decl} type identifier semicolon
        | {field_decl_and_init} type identifier equal_to expr semicolon
        | {arr_decl} type identifier l_bkt integer_param_or_value r_bkt;
    
    type =
        {bool_type} bool
        | {char_type} char
        | {float_type} float
        | {int_type} int
        | {string_type} string;
    
    method =
        {method_decl} method_hdr l_par formals r_par block
        | {no_param_method_decl} method_hdr l_par r_par block;
    
    method_hdr =
        {method_hdr_decl_void} void identifier
        | {method_hdr_decl} type identifier;
    
    formals =
        {mult_formal} formals comma formal
        | {single_formal} formal;
    
    formal =
        {formal_decl} type identifier
        | {arr_formal_decl} type identifier l_bkt r_bkt;
    
    block =
        {block_decl} l_brace stmts r_brace
        | {empty_block} l_brace r_brace;
    
    stmts =
        {mult_stmt} stmts stmt
        | {stmt} stmt;
    
    condition =
        {condition} l_par expr r_par;
    
    other_stmt =
        {local_decl} local_decl
        | {assignment} field_access equal_to expr semicolon
        | {method_call} method_call semicolon
        | {return_void} return semicolon
        | {return_expr} return expr semicolon
        | {block} block
        | {while_loop} while condition block
        | {do_while_loop} do stmts while condition semicolon
        | {no_statement} semicolon;

    stmt = 
        {matched_if} matched_if 
        | {unmatched_if} unmatched_if;

    matched_if = 
        {matched_if_def} if condition [matched_if_then]:matched_if else [matched_if_else]:matched_if
        | {other_stmt} other_stmt;

    unmatched_if = 
        {unmatched_if_without_else} if condition stmt
        | {unmatched_else_with_else} if condition [unmatched_if_then]:matched_if else [unmatched_if_else]:unmatched_if;
    
    local_decl = 
        {var_decl} type identifier semicolon
        | {var_decl_and_init} type identifier equal_to expr semicolon
        | {arr_decl} type identifier l_bkt integer_param_or_value r_bkt semicolon;
    
    field_access =
        {identifier_field_access} identifier
        | {identifier_array_access} identifier l_bkt integer_literal r_bkt
        | {identifier_empty_array_access} identifier l_bkt r_bkt
        | {array_field_access} identifier l_bkt field_access r_bkt
        | {field_extension} identifier dot field_access;
    
    method_call =
        {method_call_no_arg} field_access l_par r_par
        | {method_call_with_arg} field_access l_par args r_par;
    
    args =
        {mult_arg} args comma expr
        | {single_arg} expr;
    
    expr =
        {or_operation} expr or and_operation
        | {missing_or} and_operation;

    and_operation =
        {and_operation} and_operation and equality_operation
        | {greater_less_equal_operation} equality_operation;

    equality_operation =
        {equals_comparison} equality_operation equals greater_less_equal_operation
        | {not_equals_comparison} equality_operation not_equals greater_less_equal_operation
        | {no_equality_operation} greater_less_equal_operation;

    greater_less_equal_operation =
        {less_than} [plus_minus_src]:plus_minus_expr less_than [plus_minus_target]:plus_minus_expr
        | {greater_than} [plus_minus_src]:plus_minus_expr greater_than [plus_minus_target]:plus_minus_expr
        | {less_than_or_eq} [plus_minus_src]:plus_minus_expr less_than_or_eq [plus_minus_target]:plus_minus_expr
        | {greater_than_or_eq} [plus_minus_src]:plus_minus_expr greater_than_or_eq [plus_minus_target]:plus_minus_expr
        | {plus_minus_expr} plus_minus_expr;

    plus_minus_expr = 
        {addition} [plus_minus_expr_src]:plus_minus_expr plus [mult_div_mod_target]:mult_div_mod_expr
        | {subtraction} [plus_minus_expr_src]:plus_minus_expr minus [mult_div_mod_target]:mult_div_mod_expr
        | {mult_div_mod_expr} mult_div_mod_expr;

    mult_div_mod_expr =
        {multiplication} [mult_div_mod_expr_src]:mult_div_mod_expr mult [unitary_target]:unitary_expr
        | {division} [mult_div_mod_expr_src]:mult_div_mod_expr div [unitary_target]:unitary_expr
        | {modulo} [mult_div_mod_expr_src]:mult_div_mod_expr modulo [unitary_target]:unitary_expr
        | {unitary_expr} unitary_expr;

    unitary_expr = 
        {unary_not} not unitary_expr
        | {unary_plus} plus unitary_expr
        | {unary_minus} minus unitary_expr
        | {primary} primary;

    primary =
        {primary_field} field_access
        | {primary_method_call} method_call
        | {primary_integer_literal} integer_literal
        | {primary_char_literal} char_literal
        | {primary_string_literal} string_literal
        | {primary_float_literal} float_lit
        | {primary_true} true
        | {primary_false} false
        | {primary_expr} l_par expr r_par;

    integer_param_or_value =
        {integer_literal} integer_literal
        | {identifier} identifier;
