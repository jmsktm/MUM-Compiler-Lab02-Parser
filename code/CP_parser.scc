Helpers
    all = [0..0xffff];
    space  = ' ';          
    lf  = 0x000a; // line feed
    cr  = 0x000d; // carriage return
    ff  = 0x000c; // form feed
    ht  = 0x0009; // tab

    eol = cr | lf | cr lf;
    not_eol = [all - [cr + lf]];
    not_star = [all - '*'];
    not_star_slash = [not_star - '/'];

    valid_string_literal_chars = [not_eol - '"'];

    simple_char_seq = ' ' | '!' | '"' | '#' | '$' | '%' | '&' | '(' | ')' 
        | '*' | '+' | ',' | '-' | '.' | '/' | ':' | ';' | '<' | '=' | '>' 
        | '?' | '@' | '[' | ']' | '^' | '_' | '`' | '{' | '|' | '}' | '~'
        | ['a' .. 'z'] | ['A' .. 'Z'] | ['0' .. '9'];
    simple_escape_seq = '\\' | '\' ''' | '\n' | '\t' | '\r' | '\b' | '\f' | '\"' ;

    digit = ['0' .. '9'];
    non_zero_digit = [digit - '0'];
    digit_sequence = digit+;

    decimal = '.';
    sign = '+' | '-';
    float_mandatory_prefix_num = digit+ decimal digit*;
    float_mandatory_suffix_num = digit* decimal digit+;
    exponent_part = ('e' | 'E') sign? digit_sequence;

    underscore = '_';
    lower_alpha = ['a' .. 'z'];
    upper_alpha = ['A' .. 'Z'];
    numeric = ['0' .. '9'];
    alpha = [lower_alpha + upper_alpha];
    alpha_numeric = [alpha + numeric];
    alpha_underscore = [alpha + underscore];
    alpha_numeric_underscore = [alpha_numeric + underscore];

States
    normal;

Tokens
    comment = 
        ('//' not_eol* eol) |
        ('/*' not_star* '*'+ (not_star_slash not_star* '*'+)* '/');

    string_literal = ('"' valid_string_literal_chars* '"');
    char_literal = (''' simple_char_seq ''');
    escape_string_literal = ('"' (simple_escape_seq | valid_string_literal_chars)* '"');

    escape = (''' simple_escape_seq ''');

    plus = '+';
    minus = '-';
    mult = '*';
    div = '/';
    less_than = '<';
    less_than_or_eq= '<=';
    greater_than = '>';
    greater_than_or_eq = '>=';
    equals = '==';
    and = '&&';
    or = '||';
    not = '!';
    colon = ':';
    semicolon = ';';
    comma = ',';
    l_par = '(';
    r_par= ')';
    l_brace = '{';
    r_brace = '}';
    l_bkt= '[';
    r_bkt= ']';
    not_equals = '!=';
    equal_to = '=';
    pointer = '->';
    dot = '.';
    modulo = '%';

    float_lit = ((float_mandatory_prefix_num  | float_mandatory_suffix_num) exponent_part?);

    white_space = (space | ht | ff | eol)*;

    bool = 'bool';
    break = 'break';
    char = 'char';
    const = 'const';
    continue = 'continue';
    kclass = 'class';
    do = 'do';
    else = 'else';
    false = 'false';
    float = 'float';
    if = 'if';
    int = 'int';
    new = 'new';
    null = 'null';
    private = 'private';
    protected = 'protected';
    public = 'public';
    return = 'return';
    static = 'static';
    string = 'string';
    struct = 'struct';
    this = 'this';
    true = 'true';
    while = 'while';
    void = 'void';

    integer_literal = (non_zero_digit digit*);
    identifier = (alpha_underscore alpha_numeric_underscore*);

Ignored Tokens
    white_space,
    comment;

Productions
    program = 
        {class_decls} class_decls;
    
    class_decls =
        {mult_class_decl} class_decls class_decl
        | {single_class_decl} class_decl;
    
    class_decl =
        {empty_class_decl} class_hdr l_brace r_brace
        | {class_decl} class_hdr l_brace member_decls r_brace;
    
    class_hdr =
        {class_hdr} kclass identifier;
    
    member_decls =
        {mult_member_decl} member_decls member
        | {single_member_decl} member;
    
    member =
        {field} field
        | {method} method
        | {no_member} semicolon;
    
    field =
        {field_decl} type identifier semicolon
        | {field_decl_and_init} type identifier equal_to expr semicolon
        | {arr_decl} type identifier l_bkt integer_literal r_bkt;
    
    type =
        {bool_type} bool
        | {char_type} char
        | {float_type} float
        | {int_type} int
        | {string_type} string;
    
    method =
        {method_decl} method_hdr l_par formals r_par block
        | {no_param_method_decl} method_hdr l_par r_par block;
    
    method_hdr =
        {method_hdr_decl_void} void identifier
        | {method_hdr_decl} type identifier;
    
    formals =
        {mult_formal} formals comma formal
        | {single_formal} formal;
    
    formal =
        {formal_decl} type identifier
        | {arr_formal_decl} type identifier l_bkt r_bkt;
    
    block =
        {block_decl} l_brace stmts r_brace
        | {empty_block} l_brace r_brace;
    
    stmts =
        {mult_stmt} stmts stmt
        | {stmt} stmt;
    
    stmt = 
        {simple_stmt} simple_stmt
        | {if_else_stmt} if condition [if_stmt]:stmt else [else_stmt]:stmt;
    
    condition =
        {condition} l_par expr r_par;
    
    simple_stmt =
        {local_decl} local_decl
        | {assignment} field_access equal_to expr semicolon
        | {method_call} method_call semicolon
        | {return_void} return semicolon
        | {return_expr} return expr semicolon
        | {block} block
        | {while_loop} while condition block
        | {do_while_loop} do stmts while condition semicolon
        | {no_statement} semicolon;
    
    local_decl = 
        {var_decl} type identifier semicolon
        | {var_decl_and_init} type identifier equal_to expr semicolon
        | {arr_decl} type identifier l_bkt integer_literal r_bkt semicolon;
    
    field_access =
        {field_self} identifier
        | {field_dot_access} [main_identifier]:identifier dot [sub_identifier]:identifier
        | {array_ref} array_ref;
    
    array_ref =
        {identifier_array_ref} identifier l_bkt integer_literal r_bkt
        | {array_dot_ref} [main_identifier]:identifier dot [sub_identifier]:identifier l_bkt integer_literal r_bkt;
    
    method_call =
        {method_call_no_arg} identifier l_par r_par
        | {method_call_with_arg} identifier l_par integer_literal r_par
        | {method_call_with_dot_oper_no_arg} [main_identifier]:identifier dot [sub_identifier]:identifier l_par r_par
        | {method_call_with_dot_oper_and_arg} [main_identifier]:identifier dot [sub_identifier]:identifier l_par args r_par;
    
    args =
        {mult_arg} args comma expr
        | {single_arg} expr;
    
    expr =
        {expr_and_logical_expr} expr or logical_expr
        | {expr_or_logical_expr} expr and logical_expr
        | {logical_expr} logical_expr;

    logical_expr =
        {less_than} [plus_minus_src]:plus_minus_expr less_than [plus_minus_target]:plus_minus_expr
        | {greater_than} [plus_minus_src]:plus_minus_expr greater_than [plus_minus_target]:plus_minus_expr
        | {less_than_or_eq} [plus_minus_src]:plus_minus_expr less_than_or_eq [plus_minus_target]:plus_minus_expr
        | {greater_than_or_eq} [plus_minus_src]:plus_minus_expr greater_than_or_eq [plus_minus_target]:plus_minus_expr
        | {equals} [plus_minus_src]:plus_minus_expr equals [plus_minus_target]:plus_minus_expr
        | {not_equals} [plus_minus_src]:plus_minus_expr not_equals [plus_minus_target]:plus_minus_expr
        | {plus_minus_expr} plus_minus_expr;

    plus_minus_expr = 
        {addition} [mult_div_mod_src]:mult_div_mod_expr plus [mult_div_mod_target]:mult_div_mod_expr
        | {subtraction} [mult_div_mod_src]:mult_div_mod_expr minus [mult_div_mod_target]:mult_div_mod_expr
        | {mult_div_mod_expr} mult_div_mod_expr;

    mult_div_mod_expr =
        {multiplication} [unitary_src]:unitary_expr mult [unitary_target]:unitary_expr
        | {division} [unitary_src]:unitary_expr div [unitary_target]:unitary_expr
        | {modulo} [unitary_src]:unitary_expr modulo [unitary_target]:unitary_expr
        | {unitary_expr} unitary_expr;

    unitary_expr = 
        {unary_not} not unitary_expr
        | {unary_plus} plus unitary_expr
        | {unary_minus} minus unitary_expr
        | {primary} primary;

    primary =
        {primary_field} field_access
        | {primary_method_call} method_call
        | {primary_integer_literal} integer_literal
        | {primary_char_literal} char_literal
        | {primary_string_literal} string_literal
        | {primary_float_literal} float_lit
        | {primary_true} true
        | {primary_false} false
        | {primary_expr} l_par expr r_par;
